package edu.vt.cs5044;

import edu.vt.cs5044.tetris.AI;
import edu.vt.cs5044.tetris.Board;
import edu.vt.cs5044.tetris.Placement;
import edu.vt.cs5044.tetris.Rotation;
import edu.vt.cs5044.tetris.Shape;

/**
 * 
 * Artificial Intelligence ("AI") system that simulates a player and is capable of controlling the
 * game by placing the shapes in the best possible position on the board.
 *
 * @author trogers3
 * @version Jul 3, 2019
 *
 */
public class TetrisAI implements AI
{

    /**
     * {@inheritDoc}
     */
    @Override
    public Placement findBestPlacement(Board currentBoard, Shape shape)
    {
        /*
         * Calculate the best placement available for a shape in a board. All possible columns for
         * all possible rotations of the given shape should be considered. For each combination,
         * implementations should call Board.getResultBoard(Shape, Placement) to generate the
         * resultant board after a hypothetical placement. The implementation must calculate a
         * relative cost value for each resultant board, then return the Placement object associated
         * with the lowest cost (most preferable).
         */
        
        int bestCostValue = Integer.MAX_VALUE;

        Placement bestPlacement = null;

        for (Rotation shapeRotation : shape.getRotationSet())
        {
            for (int col = 0; col <= Board.WIDTH - shape.getWidth(shapeRotation); col++)
            {
                Placement shapePlacement = new Placement(shapeRotation, col);
                Board resultBoard = currentBoard.getResultBoard(shape, shapePlacement);

                int costValue = calculateWeightedCost(resultBoard);

                if (costValue < bestCostValue)
                {
                    bestCostValue = costValue;

                    bestPlacement = shapePlacement;
                }
            }
        }

        return bestPlacement;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getAverageColumnHeight(Board board)
    {
        /*
         * Compute the average height of all the columns of a board (see academic note). Sums the
         * total height of all columns of a board, then divides by the number of columns. Integer
         * division is used, so the result is truncated. Height is the based on the largest row
         * number containing a block. Note that if the highest row containing a block in some column
         * is r, the height of that column is r+1. Columns containing no blocks have a height of
         * zero.
         */

        // TODO Auto-generated method stub

        int sum = 0;
        for (int col = 0; col < Board.WIDTH; col++)
        {
            sum += getColumnHeight(board, col);
        }

        return sum / Board.WIDTH; // return the truncated average height of the columns.

    }

    /**
     * getAverageColumnHeight helper method
     */
    private int getColumnHeight(Board board, int col)
    {
        boolean[] colArray = board.getColumn(col);
        int columnHeight = 0;

        for (int i = 0; i < colArray.length; i++)
        {
            for (int row = 0; row < Board.HEIGHT; row++) // might delete
            {
                columnHeight = row + 1;
            }
        }
        return columnHeight;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getColumnHeightVariance(Board board)
    {
        /*
         * Return the sum of variances of adjacent column heights (see academic note). Computes the
         * sum of the absolute values of differences in heights of adjacent columns, as measured
         * from either edge of the board to the other. Note that for a board of width w, there are
         * w-1 adjacent column heights. Height is the based on the largest row number containing a
         * block. Note that if the highest row containing a block in some column is r, the height of
         * that column is r+1. Columns containing no blocks have a height of zero.
         */

        // TODO Auto-generated method stub

        int columnHeightVariance = 0;

        for (int col = 0; col < Board.WIDTH - 1; col++)
        {
            int heightDifferences = Math.abs(getColumnHeight(board, col) - getColumnHeight(board, col + 1));

            columnHeightVariance =+ heightDifferences;
        }
        
        return columnHeightVariance;

    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getTotalGapCount(Board board)
    {
        /*
         * Compute the total gap count of a board (see academic note). 
         * 
         * Counts the number of gaps residing within a board. A gap is a defined as any 
         * location without a block where a  block exists in any higher row of the same column.
         */
        
        int totalBlockCount = 0;
        boolean[] blockGaps = board.getColumn(1);
        
        for (int i = 0; i < blockGaps.length; i++)
        {
            for (int row = 0; row < Board.HEIGHT; row++)
            {
                totalBlockCount++;
                
                }
            }
        return totalBlockCount;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getColumnHeightRange(Board board)
    {
        /*
         * Compute the range of column heights of a board (see academic note). Finds the height of
         * the tallest and shortest columns within a board. Height is the based on the largest row
         * number containing a block. Note that if the highest row containing a block in some column
         * is r, the height of that column is r+1. Columns containing no blocks have a height of
         * zero. The result is the difference between the tallest and shortest heights.

         */
        // TODO Auto-generated method stub
        return 0;
    }
    
    /**
     * Place a description of your method here.
     *
     * @param board
     * @return the Max block height.
     */
    public int getMaxBlockHeight(Board board)
    {
        int currentHeight = Integer.MIN_VALUE;

        for (int col = 0; col < Board.WIDTH; col++)
        {
            int colHeight = getColumnHeight(board, col);
            if (colHeight > currentHeight) {
                currentHeight = colHeight;
            }
        }
        return currentHeight;
    }
    
    /**
     * Place a description of your method here.
     *
     * @param board
     * @return the Overall Cost of the board
     */
    public int calculateWeightedCost(Board board)
    {
        return 0;
        
    }
    

}
